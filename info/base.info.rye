section "Boolean logic " "Functions that work with true and false values." {
	group "true" 
	"Returns a truthy value. Will change to exact True value."
	{
	}

	{
		equal { true } 1
	}

	group "false" 
	"Returns a falsy value. Will change to exact Falce value"
	{
	}

	{
		equal { false } 0
	}

	group "_|" 
	"Turns a truthy value to a non-truthy and reverse."
	{
	}

	{
		equal { not true } 0
		equal { not false } 1
	}

	group "not" 
	"Turns a truthy value to a non-truthy and reverse."
	{
	}

	{
		equal { not true } 0
		equal { not false } 1
	}

	group "and" 
	"Bitwise AND operation between two values."
	{
	}

	{
		equal { true .and true } 1
		equal { false .and true } 0
	}

	group "or" 
	"Bitwise OR operation between two values."
	{
	}

	{
		equal { true .or true } 1
		equal { false .or true } 1
		equal { true .or false } 1
		equal { false .or false } 0
	}

	group "xor" 
	"Bitwise XOR operation between two values."
	{
	}

	{
		equal { true .xor true } 0
		equal { false .xor true } 1
		equal { true .xor false } 1
		equal { false .xor false } 0
	}

	group "all" 
	"Takes a block, if all values or expressions are truthy it returns the last one, otherwise false."
	{
	}

	{
		equal  { all { 1 2 3 } } 3
		equal  { all { 1 0 3 } } 0
	}

	group "any" 
	"Takes a block, if any of the values or expressions are truthy, the it returns that one, in none false."
	{
	}

	{
		equal  { any { 1 2 3 } } 1
		equal  { any { 1 0 3 } } 1
		equal  { any { 0 0 3 } } 3
	}

	group "any\with" 
	"Takes a block, if any of the values or expressions are truthy, then it returns that one, in none false."
	{
	}

	{
		equal  { any\with 10 { + 10 , * 10 } } 20
		; equal  { any\with -10 { + 10 , * 10 } } -200 ... halts TODO -- fix
	}

}

section "Numbers " "Working with numbers, integers and decimals." {
	group "inc" 
	"Returns integer value incremented by 1."
	{
	}

	{
		equal   { inc 123 } 124
		error { inc "123" }
	}

	group "is-positive" 
	"Returns true if integer is positive."
	{
	}

	{
		equal   { is-positive 123 } 1
		equal   { is-positive -123 } 0
		error { is-positive "123" }
	}

	group "is-zero" 
	"Returns true if integer is zero."
	{
	}

	{
		equal   { is-zero 0 } 1
		equal   { is-zero 123 } 0
		error { is-zero "123" }
	}

	group "is-multiple-of" 
	"Checks if a first argument is a factor of second."
	{
	}

	{
		equal { 10 .is-multiple-of 2 } 1
		equal { 10 .is-multiple-of 3 } 0
	}

	group "is-odd" 
	"Checks if a number is odd."
	{
	}

	{
		equal { 3 .is-odd } 1
		equal { 2 .is-odd } 0
	}

	group "is-even" 
	"Checks if a number is even."
	{
	}

	{
		equal { 3 .is-even } 0
		equal { 2 .is-even } 1
	}

	group "mod" 
	"Calculates module (remainder) of two integers."
	{
	}

	{
		equal { 4 .mod 2 } 0
		equal { 5 .mod 2 } 1
		equal { 5 .mod 3 } 2
	}

	group "random\integer" 
	"Accepts an integer n and returns a random integer between 0 and n in the half-open interval [0,n)."
	{
	}

	{
		equal  { random\integer 2 |type? } 'integer
		equal  { random\integer 1 |< 2 } 1
	}

	group "inc!" 
	"Searches for a word and increments it's integer value in-place."
	{
	}

	{
		equal   { a:: 123 inc! 'a a } 124
		error { inc! 123 }
	}

	group "dec!" 
	"Searches for a word and increments it's integer value in-place."
	{
	}

	{
		equal   { a:: 123 dec! 'a a } 122
		error { dec! 123 }
	}

	group "_." 
	"Accepts argument and returns void, meant to be used as drop in Eyr, void is not a valid runtime value."
	{
	}

	{
		equal { 4 . .type? } 'void
	}

	group "_+" 
	"Adds or joins two values together (Integers, Strings, Uri-s and Blocks)"
	{
	}

	{
		equal { 1 + 1 } 2
		equal { 3 + 4 } 7
		equal { 5.6 + 7.8 } 13.400000
		equal { "A" + "b" } "Ab"
		equal { "A" + 1 } "A1"
		equal { { 1 2 } + { 3 4 } } { 1 2 3 4 }
		equal { dict { "a" 1 } |+ { "b" 2 } } dict { "a" 1 "b" 2 }
		equal { dict { "a" 1 } |+ dict { "b" 2 } } dict { "a" 1 "b" 2 }
	}

	group "_-" 
	"Subtracts two numbers."
	{
	}

	{
		equal { 2 - 1 } 1
		equal { 5 - 6 } -1
	}

	group "_*" 
	"Multiplies two numbers."
	{
	}

	{
		equal { 4 * 2 } 8
		equal { 2.5 * -2 } -5.0
	}

	group "_/" 
	"Divide two numbers and return a decimal."
	{
	}

	{
		equal { 4 / 2 } 2.000
		equal { 102.0 / 2.0 } 51.000
	}

	group "_//" 
	"Divides two numbers and return truncated integer."
	{
	}

	{
		equal { 5 // 2 } 2
		equal { 102 // 5 } 20
		equal { 7.99 // 2 } 3
	}

	group "_=" 
	"Checks if two Rye values are equal."
	{
	}

	{
		equal { 5 = 5 } 1
		equal { 5 = 4 } 0
	}

	group "_>" 
	"Checks if first argument is greater than the second."
	{
	}

	{
		equal { 6 > 5 } 1
		equal { 5 > 5 } 0
	}

	group "_>=" 
	"Checks if first argument is greater or equal than the second."
	{
	}

	{
		equal { 5 >= 6 } 0
		equal { 5 >= 5 } 1
		equal { 6.0 >= 5 } 1
	}

	group "_<" 
	"Tests if Arg1 is lesser than Arg 2."
	{
	}

	{
		equal { 5 < 6 } 1
		equal { 5 < 5 } 0
	}

	group "_<=" 
	"Tests if Arg1 is lesser than Arg 2."
	{
	}

	{
		equal { 5 <= 6 } 1
		equal { 5 <= 5 } 1
	}

}

section "Strings " "" {
	group "newline" 
	"Returns the newline character."
	{
	}

	{
		equal { newline } "\n"
	}

	group "ln" 
	"Returns the argument 1 a d a newline character."
	{
	}

	{
		equal { "123" .ln } "123\n"
	}

	group "trim" 
	"Trims the String of spacing characters."
	{
	}

	{
		equal { trim " ASDF " } "ASDF"
		equal { trim "   ASDF   " } "ASDF"
	}

	group "trim\" 
	"Trims the String of specific characters."
	{
	}

	{
		equal { trim\ "__ASDF__" "_" } "ASDF"
	}

	group "trim\right" 
	"Trims the String of specific characters."
	{
	}

	{
		equal { trim\right "__ASDF__" "_" } "__ASDF"
		equal { trim\right "  ASDF  " " " } "  ASDF"
	}

	group "trim\left" 
	"Trims the String of specific characters."
	{
	}

	{
		equal { trim\left "___ASDF__" "_" } "ASDF__"
	}

	group "replace" 
	"Returns the string with all parts of the strings replaced."
	{
	}

	{
		equal { replace "...xo..." "xo" "LoL" } "...LoL..."
		equal { replace "...xoxo..." "xo" "LoL" } "...LoLLoL..."
	}

	group "substring" 
	"Returns part of the String between two positions."
	{
	}

	{
		equal { substring "xoxo..." 0 4 } "xoxo"
		equal { substring "...xoxo..." 3 7 } "xoxo"
	}

	group "contains" 
	"Returns true if argument 2 contains argument 1"
	{
	}

	{
		equal { contains "...xoxo..." "xo"  } 1
		equal { contains "...xoxo..." "lol" } 0
		equal { contains { ".." "xoxo" ".." } "xoxo" } 1
		equal { contains { ".." "xoxo" ".." } "lol"  } 0
	}

	group "has-suffix" 
	"Returns part of the String between two positions."
	{
	}

	{
		equal { has-suffix "xoxo..." "xoxo" } 0
		equal { has-suffix "...xoxo" "xoxo" } 1
	}

	group "has-prefix" 
	"Returns part of the String between two positions."
	{
	}

	{
		equal { has-prefix "xoxo..." "xoxo" } 1
		equal { has-prefix "...xoxo" "xoxo" } 0
	}

	group "index?" 
	"Returns part of the String between two positions."
	{
	}

	{
		equal { index? "...xo..." "xo" } 3
		equal { index? "xo..." "xo" } 0
		equal { index? { "xo" ".." } "xo" } 0
		equal { index? { ".." "xo" ".." } "xo" } 1
	}

	group "position?" 
	"Returns part of the String between two positions."
	{
	}

	{
		equal { position? "...xo..." "xo" } 4
		equal { position? "xo..." "xo" } 1
		equal { position? { "xo" ".." } "xo" } 1
		equal { position? { ".." "xo" ".." } "xo" } 2
	}

	group "encode\base64" 
	"decode base 64 string"
	{
	}

	{
		equal { encode\base64 "abcd" } "YWJjZA=="
	}

	group "decode\base64" 
	"decode base 64 string"
	{
	}

	{
		equal { decode\base64 encode\base64 "abcd" } "abcd"
	}

	group "space" 
	"Adds space to the end of argument"
	{
	}

	{
		equal { "abcd" .space } "abcd "
	}

	group "capitalize" 
	"Takes a String and returns the same String, but with first character turned to upper case."
	{
	}

	{
		equal { capitalize "abcde" } "Abcde"
	}

	group "to-lower" 
	"Takes a String and returns the same String, but with all characters turned to lower case."
	{
	}

	{
		equal { to-lower "ABCDE" } "abcde"
	}

	group "to-upper" 
	"Takes a String and returns the same String, but with all characters turned to upper case."
	{
	}

	{
		equal { to-upper "abcde" } "ABCDE"
	}

	group "concat3" 
	"Joins 3 Rye values together."
	{
	}

	{
		equal { concat3 "aa" "BB" "cc" } "aaBBcc"
	}

	group "join" 
	"Joins Block or list of values together."
	{
	}

	{
		equal { join { "Mary" "Anne" } } "MaryAnne"
		equal { join { "Spot" "Fido" "Rex" } } "SpotFidoRex"
	}

	group "join\with" 
	"Joins Block or list of values together."
	{
		arg `to-join`
		arg `delimiter`
	}

	{
		equal { join\with { "Mary" "Anne" } " " } "Mary Anne"
		equal { join\with { "Spot" "Fido" "Rex" } "/" } "Spot/Fido/Rex"
	}

	group "split" 
	"Splits a string into a block of values using a separator"
	{
	}

	{
		equal { split "a,b,c" "," } { "a" "b" "c" }
	}

	group "split\quoted" 
	"Splits a line of string into values by separator by respecting quotes"
	{
		arg `to-split`
		arg `splitter`
		arg `quote`
	}

	{
		equal { split\quoted "`a,b`,c,d" "," "`" } { "`a,b`" "c" "d" }
	}

	group "split\many" 
	"Splits a string into a block of values using each character in seperators as a split value"
	{
		arg `string`
		arg `separator-set`
	}

	{
		equal { split\many "192.0.0.1" "." } { "192" "0" "0" "1" }
		equal { split\many "abcd..e.q|bar" ".|" } { "abcd" "e" "q" "bar" }
	}

	group "split\every" 
	"Splits a string into chunks of length N. Leftover characters go in the last chunk"
	{
		arg `string`
		arg `N`
	}

	{
		equal { split\every "abcdefg" 3 } { "abc" "def" "g" }
		equal { split\every "abcdefg" 2 } { "ab" "cd" "ef" "g" }
		equal { split\every "abcdef" 2 } { "ab" "cd" "ef" }
	}

}

section "Collections " "" {
	group "random" 
	"Accepts an integer n and returns a random integer between 0 and n in the half-open interval [0,n)."
	{
	}

	{
		equal  { random { 1 2 3 } |type? } 'integer
	}

	group "unpack" 
	"Takes a block of Rye values and evaluates each value or expression."
	{
	}

	{
		equal  { unpack { { 123 } { 234 } } } { 123 234 }
		equal  { unpack { { { 123 } } { 234 } } } { { 123 } 234 }
	}

	group "sample" 
	"Accepts an integer n and returns a random integer between 0 and n in the half-open interval [0,n)."
	{
	}

	{
		equal  { sample { 1 2 3 4 } 2 |length? } 2
		equal  { sample { 123 123 123 123 } 3 -> 0 } 123
	}

	group "max" 
	"Accepts a Block or List of values and returns the maximal value."
	{
	}

	{
		equal { max { 8 2 10 6 } } 10
		equal { max list { 8 2 10 6 } } 10
		equal { try { max { } } |type? } 'error
		equal { try { max list { } } |type? } 'error
	}

	group "min" 
	"Accepts a Block or List of values and returns the minimal value."
	{
	}

	{
		equal { min { 8 2 10 6 } } 2
		equal { min list { 8 2 10 6 } } 2
		equal { try { min { } } |type? } 'error
		equal { try { min list { } } |type? } 'error
	}

	group "avg" 
	"Accepts a Block or List of values and returns the average value."
	{
	}

	{
		equal { avg { 8 2 10 6 } } 6.5
		equal { avg list { 8 2 10 6 } } 6.5
		equal { try { avg { } } |type? } 'error
		equal { try { avg list { } } |type? } 'error
	}

	group "sum" 
	"Accepts a Block or List of values and returns the sum."
	{
	}

	{
		equal { sum { 8 2 10 6 } } 26
		equal { sum { 8 2 10 6.5 } } 26.5
		equal { sum { } } 0
		equal { sum list { 8 2 10 6 } } 26
		equal { sum list { 8 2 10 6.5 } } 26.5
		equal { sum list { } } 0
	}

	group "mul" 
	"Accepts a Block or List of values and returns the product."
	{
	}

	{
		equal { mul { 1 2 3 4 5 } } 120
		equal { mul { 1 2.0 3.3 4 5 } } 132.0
	}

	group "first" 
	"Accepts a Block, List or String and returns the first item."
	{
	}

	{
		equal { first { 1 2 3 4 } } 1
		equal { first "abcde" } "a"
		equal { first list { 1 2 3 } } 1
	}

	group "rest" 
	"Accepts a Block, List or String and returns all but first item."
	{
	}

	{
		equal { rest { 1 2 3 4 } } { 2 3 4 }
		equal { rest "abcde" } "bcde"
		equal { rest list { 1 2 3 } } list { 2 3 }
	}

	group "rest\from" 
	"Accepts a Block, List or String and an Integer N, returns all but first N items."
	{
	}

	{
		equal { rest\from { 1 2 3 4 5 6 } 3 } { 4 5 6 }
		equal { rest\from "abcdefg" 1 } "bcdefg"
		equal { rest\from list { 1 2 3 4 } 2 } list { 3 4 }
	}

	group "tail" 
	"Accepts a Block, List or String and Integer N, returns the last N items."
	{
	}

	{
		equal { tail { 1 2 3 4 5 6 7 } 3 } { 5 6 7 }
		equal { tail "abcdefg" 4 } "defg"
		equal { tail list { 1 2 3 4 } 1 } list { 4 }
	}

	group "second" 
	"Accepts a Block, List or String and returns the second value in it."
	{
	}

	{
		equal { second { 123 234 345 } } 234
	}

	group "third" 
	"Accepts a Block, List or String and returns the third value in it."
	{
	}

	{
		equal { third { 123 234 345 } } 345
	}

	group "last" 
	"Accepts a Block, List or String and returns the last value in it."
	{
	}

	{
		equal { last { 1 2 } } 2
		equal { last "abcd" } "d"
		equal { last list { 4 5 6 } } 6
	}

	group "head" 
	"Accepts a Block, List or String and an Integer N, returns the first N values."
	{
	}

	{
		equal { head { 4 5 6 7 } 3 } { 4 5 6 }
		equal { head "abcdefg" 2 } "ab"
		equal { head "abcdefg" 4 } "abcd"
		equal { head list { 10 20 30 40 } 2 } list { 10 20 }
		equal { head { 4 5 6 7 } -2 } { 4 5 }
		equal { head "abcdefg" -1 } "abcdef"
		equal { head "abcdefg" -5 } "ab"
		equal { head list { 10 20 30 40 } -1 } list { 10 20 30 }
	}

	group "nth" 
	"Accepts a Block, List or String and Integer N, returns the N-th value."
	{
	}

	{
		equal { nth { 1 2 3 4 5 } 4 } 4
		equal { nth { "a" "b" "c" "d" "e" } 2 } "b"
	}

	group "values" 
	"Accepts a Dict and returns a List of just values."
	{
	}

	{
		equal { dict { "a" 1 "b" 2 "c" 3 } |values } list { 1 2 3 }
	}

	group "sort" 
	"Accepts a block or list and sorts in place in ascending order and returns it."
	{
	}

	{
		equal { sort { 6 12 1 } } { 1 6 12 }
		equal { sort x: { 6 12 1 } x } { 6 12 1 }
		equal { sort { "b" "c" "a" } } { "a" "b" "c" }
	}

	group "sort!" 
	"Accepts a block or list and sorts in place in ascending order and returns it."
	{
	}

	{
		error { x: { 6 12 1 } , sort! x }
		equal { x: ref { 6 12 1 } , sort! x , x } { 1 6 12 }
	}

	group "sort\by" 
	"Accepts a block or list and sorts in place in ascending order and returns it."
	{
	}

	{
		equal { sort\by { 6 12 1 } fn { a b } { a < b } } { 1 6 12 }
		equal { sort\by { 6 12 1 } fn { a b } { a > b } } { 12 6 1 }
		equal { sort\by { { x 6 } { x 12 } { x 1 } } fn { a b } { second a |< second b } } { { x 1 } { x 6 } { x 12 } }
	}

	group "unique" 
	"Accepts a block or list of values and returns only unique values."
	{
	}

	{
		equal { list { 3 2 3 5 3 2 } .unique |sort } list { 2 3 5 }
		equal { unique list { 1 1 2 2 3 } |sort } list { 1 2 3 }
		equal { unique list { 1 1 2 2 } |sort } list { 1 2 }
		equal { unique { 1 1 2 2 3 } |sort } { 1 2 3 }
		equal { unique { 1 1 2 2 } |sort } { 1 2 }
		equal { unique "aabbc" |length? } 3
		equal { unique "ab" |length? } 2
	}

	group "reverse" 
	"Accepts a block of values and returns maximal value."
	{
	}

	{
		equal { reverse { 3 1 2 3 } } { 3 2 1 3 }
		equal { reverse { 3 1 2 3 } } { 3 2 1 3 }
	}

	group "reverse!" 
	"Accepts a block of values and returns maximal value."
	{
	}

	{
		error { reverse! { 3 1 2 3 } }
		equal { reverse! ref { 3 1 2 3 } } { 3 2 1 3 }
	}

	group "concat" 
	"Joins two series values together."
	{
	}

	{
		equal { "abcd" .concat "cde" } "abcdcde"
		equal { concat { 1 2 3 4 } { 2 4 5 } } { 1 2 3 4 2 4 5 }
	}

	group "union" 
	"Accepts a block or list of values and returns only unique values."
	{
	}

	{
		; equal { "abcd" .union "cde" } "abcde"
		equal { union { 1 2 3 4 } { 2 4 5 } |length? } 5 ; order is not certain
		equal { union list { 1 2 3 4 } list { 2 4 5 } |length? } 5 ; order is not certain
		equal { union { 8 2 } { 1 9 } |sort } { 1 2 8 9 }
		equal { union { 1 2 } { } |sort } { 1 2 }
		equal { union { } { 1 9 } |sort }  { 1 9 }
		equal { union { } { } } { }
		equal { union list { 1 2 } list { 1 2 3 4 } |sort } list { 1 2 3 4 }
		equal { union list { 1 2 } list { 1 } |sort } list { 1 2 }
		equal { union list { 1 2 } list { } |sort } list { 1 2 }
		equal { union list { } list { 1 2 } |sort } list { 1 2 }
		equal { union list { } list { } } list { }
	}

	group "range" 
	"Takes two integers and returns a block of integers between them, inclusive. (Will change to lazy list/generator later)"
	{
		arg `low-value`
		arg `high-value`
	}

	{
		equal { range 1 5 } { 1 2 3 4 5 }
	}

	group "is-empty" 
	"Accepts a collection (String, Block, Dict, Table) and returns it's length."
	{
	}

	{
		equal { { } .is-empty } 1
		equal { dict { } |is-empty } 1
		equal { table { 'a 'b } { } |is-empty } 1
	}

	group "length?" 
	"Accepts a collection (String, Block, Dict, Table) and returns it's length."
	{
	}

	{
		equal { { 1 2 3 } .length? } 3
		equal { length? "abcd" } 4
		equal { table { 'val } { 1 2 3 4 } |length? } 4
		equal { vector { 10 20 30 } |length? } 3
	}

	group "keys" 
	"Accepts Dict or Table and returns a Block of keys or column names."
	{
	}

	{
		equal { dict { "a" 1 "b" 2 "c" 3 } |keys |length? } 3
		equal { table { "a" "b" "c" } { 1 2 3 } |keys |length? } 3
		; TODO -- doesn't work yet, .header? also has the same problem -- equal { table { 'a 'b 'c } { 1 2 3 } |keys } { 'a 'b 'c }
	}

	group "_->" 
	""
	{
	}

	{
		equal { { 23 34 45 } -> 1 } 34
	}

	group "_<-" 
	""
	{
	}

	{
		equal { 0 <- { 23 34 45 } } 23
	}

	group "_<~" 
	""
	{
	}

	{
		equal { 2 <~ { 23 34 45 } } 34
	}

	group "_~>" 
	""
	{
	}

	{
		equal { { 23 34 45 } ~> 1 } 23
	}

	group "intersection" 
	"Finds the intersection of two values."
	{
	}

	{
		equal { "abcd" .intersection "cde" } "cd"
		equal { intersection { 1 2 3 4 } { 2 4 5 } } { 2 4 }
		equal { intersection { 1 3 5 6 } { 2 3 4 5 } } { 3 5 }
		equal { intersection { 1 2 3 } { } } {  }
		equal { intersection { } { 2 3 4  } } { }
		equal { intersection { 1 2 3 } { 4 5 6 } } { }
		equal { intersection { } { } } { }
		equal { intersection list { 1 3 5 6 } list { 2 3 4 5 } } list { 3 5 }
		equal { intersection list { 1 2 3 } list { } } list {  }
		equal { intersection list { } list { 2 3 4 } } list { }
		equal { intersection list { 1 2 3 } list { 4 5 6 } } list { }
		equal { intersection list { } list { } } list { }
	}

	group "intersection\by" 
	"Finds the intersection of two values by custom function."
	{
	}

	{
		equal { intersection\by "foobar" "fbx" fn { a b } { a .contains b } } "fb"
		equal { intersection\by "fooBar" "Fbx" fn { a b } { a .to-lower .contains to-lower b } } "fB"
		equal { intersection\by { "foo" 33 } { 33 33 } fn { a b } { a .contains b } } { 33 }
		equal { intersection\by { "foo" "bar" 33 } { 42 } fn { a b } { map a { .type? } |contains b .type? } } { 33 }
		equal { intersection\by { { "foo" x } { "bar" y } } { { "bar" z } } fn { a b } { map a { .first } |contains first b } } { { "bar" y } }
	}

	group "difference" 
	"Finds the difference (values in first but not in second) of two values."
	{
	}

	{
		equal { "abcde" .difference "cde" } "ab"
		equal { difference { 1 2 3 4 } { 2 4 } } { 1 3 }
		equal { difference list { "Bob" "Sal" "Joe" } list { "Joe" } } list { "Bob" "Sal" }
		equal { difference "abc" "bc" } "a"
		equal { difference "abc" "abc" } ""
		equal { difference "abc" "" } "abc"
		equal { difference "" "" } ""
		equal { difference { 1 3 5 6 } { 2 3 4 5 } } { 1 6 }
		equal { difference { 1 2 3 } {  } } { 1 2 3 }
		equal { difference { } { 2 3 4  } } { }
		equal { difference { } { } } { }
		equal { difference list { 1 3 5 6 } list { 2 3 4 5 } } list { 1 6 }
		equal { difference list { 1 2 3 } list {  } } list { 1 2 3 }
		equal { difference list { } list { 2 3 4 } } list { }
		equal { difference list { } list { } } list { }
	}

	group "transpose" 
	"Accepts Block and returns the next value from it."
	{
	}

	{
		equal { { { 1 2 3 } { 4 5 6 } } .transpose } { { 1 4 } { 2 5 } { 3 6 } }
		equal { { { 1 4 } { 2 5 } { 3 6 } } .transpose } { { 1 2 3 } { 4 5 6 } }
	}

	group "remove-last!" 
	"Accepts Block and returns the next value and removes it from the Block."
	{
	}

	{
		equal { x: ref { 1 2 3 4 } remove-last! 'x x } { 1 2 3 }
		equal { x: ref { 1 2 3 4 } remove-last! 'x } { 1 2 3 }
	}

	group "append!" 
	"Accepts Rye value and Tagword with a Block or String. Appends Rye value to Block/String in place, also returns it	."
	{
	}

	{
		; TODO equal { x: ref { 1 2 3 } append! { 4 } x , x } { 1 2 3 4 }
		equal { x: ref { 1 2 3 } append! 4 'x , x } { 1 2 3 4 }
	}

	group "change\nth!" 
	"Accepts a Block or List, Integer n and a value. Changes the n-th value in the Block in place. Also returns the new series."
	{
	}

	{
		equal { x: ref { 1 2 3 } change\nth! x 2 222 , x } { 1 222 3 }
	}

}

section "Contexts " "Context related functions" {
	group "raw-context" 
	""
	{
	}

	{
		equal { c: raw-context { x: 123 } c/x } 123
		equal { y: 123 try { c: raw-context { x: y } } |type? } 'error ; word not found y
		equal { try { c: raw-context { x: inc 10 } } |type? } 'error ; word not found inc
	}

	group "isolate" 
	""
	{
	}

	{
		equal { c: isolate { x: 123 } c/x } 123
		equal { y: 123 c: isolate { x: y } c/x } 123
		equal { c: isolate { x: inc 10 } c/x } 11
		equal { y: 99 c: isolate { x: does { y } } try { c/x } |type? } 'error
		equal { y: 99 c: isolate { t: ?try x: does { t { y } } } c/x |type? } 'error
	}

	group "context" 
	"Creates a new context with no parent"
	{
	}

	{
		equal { c: context { x: 123 } c/x } 123
		equal { y: 123 c: context { x: y } c/x } 123
		equal { c: context { x: inc 10 } c/x } 11
		equal { y: 123 c: context { x: does { y } } c/x } 123
	}

	group "private" 
	"Creates a new context with current parent, returns last value"
	{
	}

	{
		equal { private { x: 123 } } 123
		equal { y: 123 private { x: y } } 123
		equal { private { x: inc 10 } } 11
		equal { y: 123 private { does { y } } :f f } 123
	}

	group "private\" 
	"Creates a new context with current parent, adds documentation, returns last value"
	{
	}

	{
		equal  { private\ "what are we doing here" { x: 234 1000 + x } } 1234
	}

	group "extends" 
	"Extends a context with a new context in place and returns it."
	{
	}

	{
		equal { ct: context { p: 123 } cn: extends ct { r: p + 234 } cn/r } 357
	}

	group "bind!" 
	""
	{
	}

	{
		equal { c: context { y: 123 } cc: bind! context { z: does { y + 234 } } c , cc/z } 357
	}

	group "unbind" 
	"Accepts a Context and unbinds it from it's parent Context."
	{
	}

	{
		equal { c: context { y: 123 } cc: bind! context { z: does { y + 234 } } c , unbind cc cc/z } 357
		error { c: context { y: 123 } cc: bind! context { z: does { y + 234 } } c , dd: unbind cc dd/z }
	}

	group "pass" 
	"Accepts a value and a block. It does the block, with value injected, and returns (passes on) the initial value."
	{
	}

	{
		equal  { 101 .pass { 202 } } 101
		equal  { 101 .pass { 202 + 303 } } 101
	}

	group "wrap" 
	"Accepts a value and a block. It does the block, with value injected, and returns (passes on) the initial value."
	{
	}

	{
		stdout { wrap { prn "*" } { prn "x" } } "*x*"
	}

	group "keep" 
	"Do the first block, then the second one but return the result of the first one."
	{
	}

	{
		equal  { 20 .keep { + 202 } { + 101 } } 222
	}

	group "change!" 
	"Searches for a word and changes it's value in-place. If value changes returns true otherwise false"
	{
	}

	{
		equal   { x: 123 , change! 234 'x , x } 234
		equal   { a:: 123 change! 333 'a a } 333
		equal   { a:: 123 change! 124 'a } 1
		equal   { a:: 123 change! 123 'a } 0
	}

	group "set!" 
	"Set word to value or words by deconstructing a block"
	{
	}

	{
		equal   { set! { 123 234 } { a b }  b } 234
	}

	group "unset!" 
	"Unset a word in current context, only meant to be used in console"
	{
	}

	{
		equal   { x: 1 unset! 'x x: 2 } 2 ; otherwise would produce an error
	}

}

section "Functions " "functions that create functions" {
	group "does" 
	"Creates a function without arguments."
	{
	}

	{
		equal { does { 123 } |type? } 'function
		equal { x: does { 123 } x } 123
	}

	group "fn1" 
	"Creates a function that accepts one anonymouse argument."
	{
	}

	{
		equal { fn1 { .pass { } } |type? } 'function
		equal { x: fn1 { } , x 123 } 123
		equal { x: fn1 { .pass { } } , x 123 } 123
		equal { x: fn1 { + 1 } , x 123 } 124
	}

	group "fn" 
	"Creates a function."
	{
	}

	{
		equal { fn { } { } |type? } 'function
		equal { x: fn { } { 234 } , x } 234
		equal { x: fn { x } { x } , x 123 } 123
		equal { x: fn { x } { + 123 } , x 123 } 246
	}

	group "pfn" 
	"Creates a pure function."
	{
	}

	{
		equal { pfn { } { } |type? } 'function
		equal { x: pfn { x } { + 123 } , x 123 } 246
		error { x: pfn { x } { .print } , x 123 }
	}

}

section "Values and Types " "" {
	group "to-word" 
	"Tries to change a Rye value to a word with same name."
	{
	}

	{
		equal { to-word "test" } 'test
		error { to-word 123 }
	}

	group "to-integer" 
	"Tries to change a Rye value (like string) to integer."
	{
	}

	{
		equal { to-integer "123" } 123
		; equal { to-integer "123.4" } 123
		; equal { to-integer "123.6" } 123
		; equal { to-integer "123.4" } 123
		error { to-integer "abc" }
	}

	group "to-decimal" 
	"Tries to change a Rye value (like string) to decimal."
	{
	}

	{
		equal { to-decimal "123.4" } 123.4
		error { to-decimal "abc" }
	}

	group "to-string" 
	"Tries to turn a Rye value to string."
	{
	}

	{
		equal { to-string 'test } "test"
		equal { to-string 123 } "123"
		equal { to-string 123.4 } "123.400000"
		equal { to-string "test" } "test"
	}

	group "to-char" 
	"Tries to turn a Rye value (like integer) to ascii character."
	{
	}

	{
		equal { to-char 42 } "*"
		error { to-char "*" }
	}

	group "to-block" 
	"Turns a List to a Block"
	{
	}

	{
		equal { list [ 1 2 3 ] |to-block |type? } 'block
		equal  { list [ 1 2 3 ] |to-block |first } 1
	}

	group "to-context" 
	"Takes a Dict and returns a Context with same names and values."
	{
	}

	{
		equal   { dict [ "a" 1 "b" 2 "c" 3 ] |to-context |type? } 'ctx   ; TODO - rename ctx to context in Rye
		; equal   { dict [ "a" 1 ] |to-context do\in { a } } '1
	}

	group "is-string" 
	"Returns true if value is a string."
	{
	}

	{
		equal   { is-string "test" } 1
		equal   { is-string 'test } 0
		equal   { is-string 123 } 0
	}

	group "is-integer" 
	"Returns true if value is an integer."
	{
	}

	{
		equal   { is-integer 123 } 1
		equal   { is-integer 123.4 } 0
		equal   { is-integer "123" } 0
	}

	group "is-decimal" 
	"Returns true if value is a decimal."
	{
	}

	{
		equal   { is-decimal 123.0 } 1
		equal   { is-decimal 123 } 0
		equal   { is-decimal "123.4" } 0
	}

	group "is-number" 
	"Returns true if value is a number (integer or decimal)."
	{
	}

	{
		equal   { is-number 123 } 1
		equal   { is-number 123.4 } 1
		equal   { is-number "123" } 0
	}

	group "to-uri" 
	"Tries to change Rye value to an URI."
	{
	}

	{
		equal   { to-uri "https://example.com" } https://example.com
		; error { to-uri "not-uri" }
	}

	group "to-file" 
	"Tries to change Rye value to a file."
	{
	}

	{
		equal   { to-file "example.txt" } %example.txt
		equal { to-file 123 } %123
	}

	group "type?" 
	"Returns the type of Rye value as a word."
	{
	}

	{
		equal   { type? "test" } 'string
		equal   { type? 123.4 } 'decimal
	}

	group "kind?" 
	"Returns the type of Rye value as a word."
	{
	}

	{
		equal   { kind? %file } 'file-schema
	}

	group "types?" 
	"Returns the types of Rye values in a block or table row as a block of words."
	{
	}

	{
		equal   { types? { "test" 123 } } { string integer }
	}

	group "dump" 
	"Returns (dumps) Rye code representing the object."
	{
	}

	{
		equal { dump 123 } "123"
		equal { dump "string" } `"string"`
		equal { does { 1 } |dump } "fn { } { 1 }"
	}

	group "mold" 
	"Turn value to it's string representation."
	{
	}

	{
		equal  { mold 123 } "123"
		equal  { mold { 123 } } "{ 123 }"
	}

	group "mold\nowrap" 
	"Turn value to it's string representation. Doesn't wrap the blocks"
	{
	}

	{
		equal  { mold\nowrap 123 } "123"
		equal  { mold\nowrap { 123 } } "123"
		equal  { mold\nowrap { 123 234 } } "123 234"
	}

	group "doc!" 
	"Sets docstring of the current context."
	{
	}

	{
		equal   { x: private { doc! "some doc" doc? } } "some doc"
	}

	group "doc?" 
	"Gets docstring of the current context."
	{
	}

	{
		equal   { x: private { doc! "some doc" doc? } } "some doc"
	}

	group "doc\of?" 
	"Get docstring of the passed context."
	{
	}

	{
		equal   { x: context { doc! "some doc" } doc\of? x } "some doc"
	}

	group "ref" 
	"Makes a value mutable instead of immutable"
	{
	}

	{
		equal   { is-ref ref { 1 2 3 } } 1
	}

	group "deref" 
	"Makes a value again immutable"
	{
	}

	{
		equal   { is-ref deref ref { 1 2 3 } } 0
	}

	group "is-ref" 
	"Prints information about a value."
	{
	}

	{
		equal  { ref { } |is-ref } true
		equal  { { } |is-ref } false
	}

	group "dict" 
	"Constructs a Dict from the Block of key and value pairs."
	{
	}

	{
		equal { dict { "a" 123 } -> "a" } 123
	}

	group "list" 
	"Constructs a List from the Block of values."
	{
	}

	{
		equal { list { "a" 123 } -> 0 } "a"
	}

}

section "Printing " "" {
	group "prns" 
	"Prints a value and adds a space."
	{
	}

	{
		stdout { prns "xy" } "xy "
	}

	group "prn" 
	"Prints a value without newline."
	{
	}

	{
		stdout { prn "xy" } "xy"
	}

	group "print" 
	"Prints a value and adds a newline."
	{
	}

	{
		stdout { print "xy" } "xy\n"
	}

	group "format" 
	"Formats a value according to Go-s sprintf format"
	{
	}

	{
		equal { format 123  "num: %d" } "num: 123"
	}

	group "prnf" 
	"Formats a value according to Go-s sprintf format and prn-s it"
	{
	}

	{
		stdout { prnf 123 "num: %d" } "num: 123"
	}

	group "embed" 
	"Embeds a value into a string with {} placeholder."
	{
	}

	{
		equal   { embed 101 "val {}" } "val 101"
	}

	group "prnv" 
	"Prints a value."
	{
	}

	{
		stdout  { prnv 101 "val {}" } "val 101"
	}

	group "printv" 
	"Prints a value and adds a newline."
	{
	}

	{
		stdout  { printv 101 "val {}" } "val 101\n"
	}

	group "print\ssv" 
	"Prints a value and adds a newline."
	{
	}

	{
		stdout  { print\ssv { 101 "asd" } } "101 asd\n"
	}

	group "print\csv" 
	"Prints a value and adds a newline."
	{
	}

	{
		stdout  { print\csv { 101 "asd" } } "101,asd\n"
	}

	group "probe" 
	"Prints information about a value."
	{
	}

	{
		stdout  { probe 101 } "[Integer: 101]\n"
	}

	group "inspect" 
	"Returs information about a value."
	{
	}

	{
		equal  { inspect 101 } "[Integer: 101]"
	}

	group "esc" 
	"Creates an escape sequence \033{}"
	{
	}

	{
		; equal  { esc "[33m" } "\033[33m"   ; we can't represent hex or octal in strings yet
	}

	group "esc-val" 
	"Escapes a value and adds a newline."
	{
	}

	{
		; equal  { esc-val "[33m" "Error" } "\033[33mError"  ; we can't represent hex or octal in strings yet
	}

	group "load" 
	"Loads a string into Rye values."
	{
	}

	{
		equal  { load " 1 2 3 " |third } 3
		equal  { load "{ 1 2 3 }" |first |third } 3
	}

}

section "Flow control " "" {
	group "if" 
	"Basic conditional. Takes a condition and a block of code."
	{
	}

	{
		equal  { if 1 { 222 } } 222
		equal  { if 0 { 333 } } 0
	}

	group "^if" 
	"Basic conditional with a Returning mechanism when true. Takes a condition and a block of code."
	{
	}

	{
		equal  { x: does { ^if 1 { 222 } 555 } x } 222
		equal  { x: does { ^if 0 { 333 } 444 } x } 444
	}

	group "either" 
	"The if/else conditional. Takes a value and true and false block of code."
	{
	}

	{
		equal  { either 1 { 222 } { 333 } } 222
		equal  { either 0 { 222 } { 333 } } 333
	}

	group "switch" 
	"Classic switch function. Takes a word and multiple possible values and block of code to do."
	{
	}

	{
		equal  { switch 101 { 101 { 111 } 202 { 222 } } } 111
		equal  { switch 202 { 101 { 111 } 202 { 222 } } } 222
	}

	group "cases" 
	"Similar to Case function, but checks all the cases, even after a match. It combines the outputs."
	{
	}

	{
		equal  { cases 0 { { 1 > 0 } { + 100 } { 2 > 1 } { + 1000 } } } 1100
		equal  { cases 0 { { 1 > 0 } { + 100 } { 2 < 1 } { + 1000 } } } 100
		equal  { cases 0 { { 1 < 0 } { + 100 } { 2 > 1 } { + 1000 } } } 1000
		equal  { cases 0 { { 1 < 0 } { + 100 } { 2 < 1 } { + 1000 } } } 0
		equal  { cases 1 { { 1 > 0 } { + 100 } { 2 < 1 } { + 1000 } _ { * 3 } } } 101
		equal  { cases 1 { { 1 < 0 } { + 100 } { 2 > 1 } { + 1000 } _ { * 3 } } } 1001
		equal  { cases 1 { { 1 < 0 } { + 100 } { 2 < 1 } { + 1000 } _ { * 3 } } } 3
	}

	group "do" 
	"Takes a block of code and does (runs) it."
	{
	}

	{
		equal  { do { 123 + 123 } } 246
		error  { do { 123 + } }
		equal  { do { _+ _+ 12 23 34 } } 69
		equal  { do { 12 * 23 |+ 34 } } 310
		equal  { do { ( 12 * 23 ) + 34 } } 310
		equal  { do { 12 * 23 | + 34 } } 310
		equal  { do { 12 * 23 :a + 34 } } 310
		equal  { do { 12 * 23 :a a + 34 } } 310
	}

	group "try" 
	"Takes a block of code and does (runs) it."
	{
	}

	{
		equal  { try { 123 + 123 } } 246
		equal  { try { 123 + "asd" } \type? } 'error
		equal  { try { 123 + } \type? } 'error
	}

	group "with" 
	"Takes a value and a block of code. It does the code with the value injected."
	{
	}

	{
		equal  { with 100 { + 11 } } 111
		equal  { with 100 { + 11 , * 3 } } 300
	}

	group "do\in" 
	"Takes a Context and a Block. It Does a block inside a given Context."
	{
	}

	{
		equal  { c: context { x: 100 } do\in c { x * 9.99 } } 999.0
		equal  { c: context { x: 100 } do\in c { inc! 'x } } 101
		equal  { c: context { x: 100 } do\in c { x:: 200 } c/x } 200
		equal  { c: context { x: 100 } do\in c { x:: 200 , x } } 200
	}

	group "try\in" 
	"Takes a Context and a Block. It Does a block inside a given Context."
	{
	}

	{
		equal  { c: context { x: 100 } try\in c { x * 9.99 } } 999.0
		equal  { c: context { x: 100 } try\in c { inc! 'x } } 101
		equal  { c: context { x: 100 } try\in c { x:: 200 , x } } 200
		equal  { c: context { x: 100 } try\in c { x:: 200 } c/x } 200
		equal  { c: context { x: 100 } try\in c { inc! 'y } |type? } 'error
	}

	group "do\par" 
	"Takes a Context and a Block. It Does a block in current context but with parent a given Context."
	{
	}

	{
		equal  { c: context { x: 100 } do\par c { x * 9.99 } } 999.0
		equal  { c: context { x: 100 } do\par c { inc! 'x } } 101
		equal  { c: context { x: 100 } do\par c { x:: 200 , x } } 200
		equal  { c: context { x: 100 } do\par c { x:: 200 } c/x } 100
	}

	group "capture-stdout" 
	"Takes a block of code and does (runs) it."
	{
	}

	{
		equal { capture-stdout { print "hello" } } "hello\n"
		equal { capture-stdout { loop 3 { prns "x" } } } "x x x "
	}

	group "time-it" 
	"Accepts a block, does it and times it's execution time."
	{
	}

	{
		equal { time-it { sleep 100 } } 100
	}

	group "vals" 
	"Takes a block of Rye values and evaluates each value or expression."
	{
	}

	{
		equal { x: 1 y: 2 vals { x y } } { 1 2 }
		equal { x: 1 y: 2 vals { 1 y } } { 1 2 }
		equal { x: 1 y: 2 try { vals { z y } } |type? } 'error
	}

	group "vals\with" 
	"Evaluate a block with injecting the first argument."
	{
	}

	{
		equal { x: 1 y: 2 vals\with 10 { + x , * y } } { 11 20 }
		equal { x: 1 y: 2 vals\with 100 { + 10 , * 8.9 } } { 110 890.0 }
	}

	group "current" 
	"Returns current context."
	{
	}

	{
		equal { c: context { x: 9999 , incr: fn\in { } current { x:: inc x } } c/incr c/x } 10000
	}

	group "parent" 
	"Returns parent context of the current context."
	{
	}

	{
		equal { y: 99 c: context { incr: fn\in { } parent { y:: inc y } } c/incr y } 100
	}

	group "parent\of" 
	"Returns parent context of the current context."
	{
	}

	{
		equal { ct: context { p: 123 } parent\of ct |= current } 1
	}

}

section "Iteration " "Iteration over collections" {
	group "loop" 
	"Accepts a number and a block of code. Does the block of code number times, injecting the number."
	{
	}

	{
		stdout { 3 .loop { prns "x" } } "x x x "
		equal  { 3 .loop { + 1 } } 4
		; equal  { 3 .loop { } } 3  ; TODO should pass the value
	}

	group "produce" 
	"Accepts a number, initial value and a block of code. Does the block of code number of times, injecting the initial value or last result."
	{
	}

	{
		equal { produce 5 0 { + 3 } } 15
		equal { produce 3 ">" { + "x>" } } ">x>x>x>"
		equal { produce 3 { } { .concat "x" } } { "x" "x" "x" }
		equal { produce 3 { } { ::x .concat length? x } } { 0 1 2 }
		equal { produce 5 { 2 } { ::acc .last ::x * x |concat* acc } } { 2 4 16 256 65536 4294967296 }
	}

	group "produce\while" 
	"Accepts a while condition, initial value and a block of code. Does the block of code number times, injecting the number first and then result of block."
	{
	}

	{
		equal { x: 0 produce\while { x < 100 } 1 { * 2 ::x } } 64
		stdout { x: 0 produce\while { x < 100 } 1 { * 2 ::x .prns } } "2 4 8 16 32 64 128 "
	}

	group "produce\" 
	" TODO "
	{
	}

	{
		equal { produce\ 5 1 'acc { * acc , + 1 } } 1  ; Look at what we were trying to do here
	}

	group "forever" 
	"Accepts a block and does it forever."
	{
	}

	{
		stdout { forever { "once" .prn .return } } "once"
		equal { forever { "once" .return } } "once"
	}

	group "forever\with" 
	""
	{
	}

	{
		stdout { forever\with 1 { .prn .return } } "1"
	}

	group "for___" 
	"Accepts a block of values and a block of code, does the code for each of the values, injecting them."
	{
	}

	{
		stdout { for { 1 2 3 } { prns "x" } } "x x x "
		stdout { { "a" "b" "c" } .for { .prns } } "a b c "
	}

	group "for" 
	"Accepts a block of values and a block of code, does the code for each of the values, injecting them."
	{
	}

	{
		stdout { for { 1 2 3 } { prns "x" } } "x x x "
		stdout { { "a" "b" "c" } .for { .prns } } "a b c "
	}

	group "walk" 
	"Accepts a block of values and a block of code, does the code for each of the values, injecting them."
	{
	}

	{
		stdout { walk { 1 2 3 } { .prns .rest } } "1 2 3  2 3  3  "
		equal { x: 0 walk { 1 2 3 } { ::b .first + x ::x , b .rest } x } 6
	}

	group "purge" 
	"Purges values from a series based on return of a injected code block."
	{
	}

	{
		equal { purge { 1 2 3 } { .is-even } } { 1 3 }
		equal { purge { } { .is-even } } { }
		equal { purge list { 1 2 3 } { .is-even } } list { 1 3 }
		equal { purge list { } { .is-even } } list { }
		equal { purge "1234" { .to-integer .is-even } } { "1" "3" }
		equal { purge "" { .to-integer .is-even } } { }
	}

	group "purge!" 
	"Purges values from a series based on return of a injected code block."
	{
	}

	{
		equal { { 1 2 3 } :x purge! { .is-even } 'x , x } { 1 3 }
	}

	group "map___" 
	"Maps values of a block to a new block by evaluating a block of code."
	{
	}

	{
		equal { map { 1 2 3 } { + 1 } } { 2 3 4 }
		equal { map { } { + 1 } } { }
		equal { map { "aaa" "bb" "c" } { .length? } } { 3 2 1 }
		equal { map list { "aaa" "bb" "c" } { .length? } } list { 3 2 1 }
		equal { map list { 3 4 5 6 } { .is-multiple-of 3 } } list { 1 0 0 1 }
		equal { map list { } { + 1 } } list { }
		; equal { map "abc" { + "-" } .join } "a-b-c-" ; TODO doesn't work, fix join
		equal { map "123" { .to-integer } } { 1 2 3 }
		equal { map "123" ?to-integer } { 1 2 3 }
		equal { map "" { + "-" } } { }
	}

	group "map" 
	"Maps values of a block to a new block by evaluating a block of code."
	{
	}

	{
		equal { map { 1 2 3 } { + 1 } } { 2 3 4 }
		equal { map { } { + 1 } } { }
		equal { map { "aaa" "bb" "c" } { .length? } } { 3 2 1 }
		equal { map list { "aaa" "bb" "c" } { .length? } } list { 3 2 1 }
		equal { map list { 3 4 5 6 } { .is-multiple-of 3 } } list { 1 0 0 1 }
		equal { map list { } { + 1 } } list { }
		; equal { map "abc" { + "-" } .join } "a-b-c-" ; TODO doesn't work, fix join
		equal { map "123" { .to-integer } } { 1 2 3 }
		equal { map "123" ?to-integer } { 1 2 3 }
		equal { map "" { + "-" } } { }
	}

	group "map\pos" 
	"Maps values of a block to a new block by evaluating a block of code."
	{
	}

	{
		equal { map\pos { 1 2 3 } 'i { + i } } { 2 4 6 }
		equal { map\pos { } 'i { + i } } { }
		equal { map\pos list { 1 2 3 } 'i { + i } } list { 2 4 6 }
		equal { map\pos list { } 'i { + i } } list { }
		equal { map\pos "abc" 'i { + i } } { "a1" "b2" "c3" }
		equal { map\pos "" 'i { + i } } { }
	}

	group "map\idx" 
	"Maps values of a block to a new block by evaluating a block of code."
	{
	}

	{
		equal { map\idx { 1 2 3 } 'i { + i } } { 1 3 5 }
		equal { map\idx { } 'i { + i } } { }
		equal { map\idx list { 1 2 3 } 'i { + i } } list { 1 3 5 }
		equal { map\idx list { } 'i { + i } } list { }
		equal { map\idx "abc" 'i { + i } } { "a0" "b1" "c2" }
		equal { map\idx "" 'i { + i } } { }
	}

	group "reduce" 
	"Reduces values of a block to a new block by evaluating a block of code ..."
	{
	}

	{
		equal { reduce { 1 2 3 } 'acc { + acc } } 6
		equal { reduce list { 1 2 3 } 'acc { + acc } } 6
		equal { reduce "abc" 'acc { + acc } } "cba"
		equal { try { reduce { } 'acc { + acc } } |type? } 'error
		equal { try { reduce list { } 'acc { + acc } } |type? } 'error
		equal { try { reduce "" 'acc { + acc } } |type? } 'error
	}

	group "fold" 
	"Reduces values of a block to a new block by evaluating a block of code ..."
	{
	}

	{
		equal { fold { 1 2 3 } 'acc 1 { + acc } } 7
		equal { fold { } 'acc 1 { + acc } } 1
		equal { fold list { 1 2 3 } 'acc 1 { + acc } } 7
		equal { fold list { } 'acc 1 { + acc } } 1
		equal { fold "abc" 'acc "123" { + acc } } "cba123"
		equal { fold "" 'acc "123" { + acc } } "123"
	}

	group "partition" 
	"Partitions a series by evaluating a block of code."
	{
	}

	{
		equal { partition { 1 2 3 4 } { > 2 } } { { 1 2 } { 3 4 } }
		equal { partition { "a" "b" 1 "c" "d" } { .is-integer } } { { "a" "b" } { 1 } { "c" "d" } }
		equal { partition { "a" "b" 1 "c" "d" } ?is-integer } { { "a" "b" } { 1 } { "c" "d" } }
		equal { partition { } { > 2 } } { { } }
		equal { partition list { 1 2 3 4 } { > 2 } } list vals { list { 1 2 } list { 3 4 } }
		equal { partition list { "a" "b" 1 "c" "d" } ?is-integer } list vals { list { "a" "b" } list { 1 } list { "c" "d" } }
		equal { partition list { } { > 2 } } list vals { list { } }
		equal { partition "aaabbccc" { , } } list { "aaa" "bb" "ccc" }
		equal { partition "" { , } } list { "" }
		equal { partition "aaabbccc" ?is-string } list { "aaabbccc" }
	}

	group "group" 
	"Groups a block or list of values given condition."
	{
	}

	{
		; Equality for dicts doesn't yet work consistently
		;equal { { "Anne" "Mitch" "Anya" } .group { .first } } dict vals { "A" list { "Anne" "Anya" } "M" list { "Mitch" } }
		;equal { { "Anne" "Mitch" "Anya" } .group ?first } dict vals { "A" list { "Anne" "Anya" } "M" list { "Mitch" } }
		;equal { { } .group { .first } } dict vals { }
		;equal { { "Anne" "Mitch" "Anya" } .list .group { .first } } dict vals { "A" list { "Anne" "Anya" } "M" list { "Mitch" } }
		;equal { { "Anne" "Mitch" "Anya" } .list .group ?first } dict vals { "A" list { "Anne" "Anya" } "M" list { "Mitch" } }
		equal { { } .list .group { .first } } dict vals { }
		equal { try { { 1 2 3 4 } .group { .is-even } } |type? } 'error ; TODO keys can only be string currently
	}

	group "filter" 
	"Filters values from a seris based on return of a injected code block."
	{
	}

	{
		equal { filter { 1 2 3 4 } { .is-even } } { 2 4 }
		equal { filter { 1 2 3 4 } ?is-even } { 2 4 }
		equal { filter { } { .is-even } } { }
		equal { filter list { 1 2 3 4 } { .is-even } } list { 2 4 }
		equal { filter list { 1 2 3 4 } ?is-even } list { 2 4 }
		equal { filter list { } { .is-even } } list { }
		equal { filter "1234" { .to-integer .is-even } } { "2" "4" }
		equal { filter "01234" ?to-integer } { "1" "2" "3" "4" }
		equal { filter "" { .to-integer .is-even } } { }
	}

	group "seek" 
	"Seek over a series until a Block of code returns True and return the value."
	{
	}

	{
		equal { seek { 1 2 3 4 } { .is-even } } 2
		equal { seek list { 1 2 3 4 } { .is-even } } 2
		equal { seek "1234" { .to-integer .is-even } } "2"
		equal { try { seek { 1 2 3 4 } { > 5 } } |type? } 'error
		equal { try { seek list { 1 2 3 4 } { > 5 } } |type? } 'error
		equal { try { seek "1234" { .to-integer > 5 } } |type? } 'error
	}

}

section "Other " "functions related to date and time" {
	group "return" 
	"Accepts one value and returns it."
	{
	}

	{
		equal { x: fn { } { return 101 202 } x } 101
	}

	group "year-day?" 
	"Returns the day in the given time."
	{
		arg `time`
	}

	{
	}

	group "year?" 
	"Returns the year of the given time."
	{
		arg `time`
	}

	{
	}

	group "month?" 
	"Returns current month as an integer."
	{
		arg `time`
	}

	{
	}

	group "days-in-month?" 
	"Returns the days in the month that `time` is in."
	{
		arg `time`
	}

	{
	}

	group "time?" 
	"Returns Time part of a datetime."
	{
		arg `time`
	}

	{
	}

	group "date?" 
	"Returns date part of datetime."
	{
		arg `time`
	}

	{
	}

	group "day?" 
	"Returns the day of month of the given time."
	{
		arg `time`
	}

	{
	}

	group "hour?" 
	"Returns the hour of the given time."
	{
		arg `time`
	}

	{
	}

	group "minute?" 
	"Returns the minute of the given time."
	{
		arg `time`
	}

	{
	}

	group "second?" 
	"Returns the second of the given time."
	{
		arg `time`
	}

	{
	}

	group "cmd" 
	"Execute a shell command."
	{
	}

	{
		equal { cmd `echo "hello"` } 1
	}

	group "rye" 
	""
	{
	}

	{
		equal { rye .type? } 'native
	}

	group "sleep" 
	"Accepts an integer and Sleeps for given number of miliseconds."
	{
	}

	{
		equal { time-it { sleep 10 } } 10
	}

	group "seconds" 
	"Accepts an integer and Sleeps for given number of miliseconds."
	{
	}

	{
		equal  { 5 .seconds } 5000000000
	}

	group "minutes" 
	"Accepts an integer and Sleeps for given number of miliseconds."
	{
	}

	{
		equal  { 5 .minutes } 5000000000 * 60
	}

	group "hours" 
	"Accepts an integer and Sleeps for given number of miliseconds."
	{
	}

	{
		equal  { 5 .hours } 5000000000 * 60 * 60
	}

}

