; Test / docs definition ... mold/nowrap ?function get's docstrings from live functions
; title "Function reference: core builtins"

section "Printing functions"
"Functions that print values to stdout."
{
	group "print"
	mold\nowrap ?print
	{ { object } }
	{
		stdout { print 123 } "123" + newline
	}
	group "prn"
	mold\nowrap ?prn
	{ { object } }
	{
		stdout { prn 123 } "123"
	}
	group "prns"
	mold\nowrap ?prns
	{ { object } }
	{
		stdout { prns 123 } "123 "
	}
	group "print\val"
	mold\nowrap ?print\val
	{ { object } }
	{
		stdout { print\val 33 "value is: {{}}" } "value is: 33" + newline
	}
	; group "print-ssv"
	; mold\nowrap ?print-ssv
	; { { function } }
	; {
	; }
	$ group "print-csv"
	mold\nowrap ?print-csv
	{ { function } }
	{
	}
	group "print-json"
	mold\nowrap ?print-json
	{ { function } }
	{
	} $
	group "probe"
	mold\nowrap ?probe
	{ { function } }
	{
		stdout { probe 33 } "[Integer: 33]" + newline
	}
	; group "inspect"
	; mold\nowrap ?inspect
	; { { function } }
	; {
	;	stdout { inspect 33 } "33"
	; }
}

section "Working with numbers"
"Functions that mostly work with numbers."
{
	group "inc"
	mold\nowrap ?inc
	{ { integer } }
	{
		equal { inc 100 } 101
	}

	group "is-positive"
	mold\nowrap ?is-positive
	{ { integer decimal } }
	{
		equal { is-positive 1 } 1 
		equal { 0 .is-positive } 0 
		; TODO equal { -1 .is-positive } 0
		; TODO -- same for decimal
	}

	group "is-zero"
	mold\nowrap ?is-zero
	{ { integer decimal } }
	{
		equal { is-zero 0 } 1
		equal { 0 .is-zero } 1
		equal { is-zero 0.0 } 1
		equal { is-zero 0.1 } 0
	}

	group "factor-of"
	mold\nowrap ?factor-of
	{ { integer } { integer } }
	{
		equal { factor-of 10 2 } 1
		equal { 10 .factor-of 3 } 0		
	}

	group "odd"
	mold\nowrap ?odd
	{ { integer } }
	{
		equal { odd 3 } 1
		; TODO 
	}

	group "even"
	mold\nowrap ?even
	{ { integer } }
	{
		equal { even 2 } 1
		; TODO
	}

	group "mod"
	mold\nowrap ?mod
	{ { integer } { integer } }
	{
		equal { 3 .mod 2 } 1
		; TODO
	}

	$ 
	group "+-*/"
	""
	{ { integer decimal } { integer decimal } }
	{
	}


	group "!=><+"
	""
	{ { integer decimal } { integer decimal } }
	{
	} $

}


section "Logic functions"
"Function that help with logical operations."
{	

	group "true"
	mold\nowrap ?true
	{ { } }
	{
		equal { true } 1
	}

	group "false"
	mold\nowrap ?false
	{ { function } }
	{
		equal { false } 0
	}
	
	group "not"
	mold\nowrap ?not
	{ { function } }
	{
		equal { not 0 } 1
		equal { not 1 } 0
	}
	
	group "all"
	mold\nowrap ?all
	{ { block } }
	{
		equal { all { 1 1 1 } } 1
		equal { { 0 0 1 } .all } 0
	}

	group "any"
	mold\nowrap ?any
	{ { block } }
	{
		equal { any { 0 0 1 } } 1
		equal { { 0 0 0 } .any } 0
	}

	;group "any\with"
	;mold\nowrap ?any\with
	;{ { object } { block } }
	;{
	;	equal { any\with 1 {  + 0 , + 0  } } 1
	;}
}

section "Working with strings"
"Functions that mostly work with strings."
{	

	group "capitalize"
	mold\nowrap ?capitalize
	{ { string } }
	{
		equal { capitalize "anne" } "Anne"
	}

	group "to-lower"
	mold\nowrap ?to-lower
	{ { string } }
	{
		equal { to-lower "ANNE" } "anne"
	}

	group "to-upper"
	mold\nowrap ?to-upper
	{ { string } }
	{
		equal { to-upper "anne" } "ANNE"
	}

	group "join"
	mold\nowrap ?join
	{ { block list } }
	{
		equal { join [ "Marry" "Anne" ] } "MarryAnne"
	}
	
	group "join\with"
	mold\nowrap ?join\with
	{ { block list } { string } }
	{
		equal { join\with [ "Marry" "Anne" ] "," } "Marry,Anne"
	}

	group "split"
	mold\nowrap ?split
	{ { string } { string } }
	{
		equal { split "Marry,Anne" "," } { "Marry" "Anne" }
	}

	group "split\quoted"
	mold\nowrap ?split\quoted
	{ { string } { string } }
	{
		equal { split\quoted $"Marry,Anne",Joe$ "," $"$ } { "Marry,Anne" "Joe" } ;" }
	}
	
	group "split\every"
	mold\nowrap ?split\every
	{ { string } { integer } }
	{
		equal { split\every "abcbce" 3 } { "abc" "bce" }
	}
	
	comment "Many of functions that work with other collections also work with strings."
}

section "Working with blocks and lists"
"Functions that mostly work with collections (blocks / lists)."
{	
	
	group "range"
	mold\nowrap ?range
	{ { integer } { integer } }
	{
		equal { range 1 5 } { 1 2 3 4 5 }
	}
	
	group "first"
	mold\nowrap ?first
	{ { block } }
	{
		equal { first { 1 2 3 4 5 } } 1
	}

	group "rest"
	mold\nowrap ?rest
	{ { block } }
	{
		equal { rest { 1 2 3 4 5 } } { 2 3 4 5 }
	}

	group "rest\from"
	mold\nowrap ?rest\from
	{ { block } { integer } }
	{
		equal { rest\from { 1 2 3 4 5 } 2 } { 3 4 5 }
	}

	group "second"
	mold\nowrap ?second
	{ { block } }
	{
		equal { second { 1 2 3 4 5 } } 2
	}

	group "third"
	mold\nowrap ?third
	{ { block } }
	{
		equal { third { 1 2 3 4 5 } } 3
	}

	group "nth"
	mold\nowrap ?nth
	{ { block } }
	{
		equal { nth { 1 2 3 4 5 } 4 } 4
	}
	
	group "last"
	mold\nowrap ?last
	{ { block } }
	{
		equal { last { 1 2 3 4 5 } } 5
	}
	
	group "head"
	mold\nowrap ?head
	{ { block } { integer } }
	{
		equal { head { 1 2 3 4 5 } 2 } { 1 2 }
	}

		
	group "tail"
	mold\nowrap ?tail
	{ { block } { integer } }
	{
		equal { tail { 1 2 3 4 5 } 2 } { 4 5 }
	}

	group "length?"
	mold\nowrap ?length?
	{ { block string list } }
	{
		equal { length? "1234567" } 7
		equal { { 1 2 3 4 5 } .length? } 5
		equal { list { 1 2 3 } |length? } 3
	}
	
	group "list"
	mold\nowrap ?list
	{ { block } }
	{
		equal { list { "a" 1 "b" 2 } |type? } 'list
	}

	group "dict"
	mold\nowrap ?dict
	{ { block } }
	{
		equal { dict { "a" 1 "b" 2 } |type? } 'dict
	}


}


section "Type conversion and checking"
"Functions that convert between Rye value types."
{
	group "to-word"
	mold\nowrap ?to-word
	{ { string word } }
	{
		equal { to-word "test" } 'test
		equal { to-word 'test } 'test
	}
	group "to-integer"
	mold\nowrap ?to-integer
	{ { string number } }
	{
		equal { to-integer "123" } 123
	}

	group "to-string"
	mold\nowrap ?to-string
	{ { string word number } }
	{
		equal { to-string 123 } "123"
		equal { to-string 'word } "word"
	}

	group "to-uri"
	mold\nowrap ?to-uri
	{ { string } }
	{
		equal { to-uri "https://example.com" } https://example.com
	}

	group "to-file"
	mold\nowrap ?to-file
	{ { string } }
	{
		equal { to-file "file.txt" } %file.txt
	}

	group "is-integer"
	mold\nowrap ?is-integer
	{ { object } }
	{
		equal { is-integer 123 } 1
		equal { is-integer "ABC" } 0
	}

	group "is-decimal"
	mold\nowrap ?is-decimal
	{ { object } }
	{
		equal { is-decimal 123.456 } 1
		equal { is-decimal 123 } 0
		equal { is-decimal "ABC" } 0
	}

	group "is-number"
	mold\nowrap ?is-number
	{ { object } }
	{
		equal { is-number 123 } 1
		equal { is-number 123.456 } 1
		equal { is-number "ABC" } 0
	}

	group "is-string"
	mold\nowrap ?is-string
	{ { object } }
	{
		equal { is-string "ABC" } 1
		equal { is-string 123 } 0
		equal { is-string %file.txt } 0
		equal { is-string test@gmail.com } 0
	}

	group "type?"
	mold\nowrap ?type?
	{ { object } }
	{
		equal { type? "ABC" } 'string
		equal { type? 123 } 'integer
		; TODO -- add for other types
	}
}

section "Serializing values"
"Functions that print values to stdio"
{
	group "mold"
	mold\nowrap ?mold
	{ { function } }
	{
		equal { mold 33 } "33"
	}
	group "mold\unwrap"
	mold\nowrap ?mold\nowrap
	{ { function } }
	{
		equal { mold\nowrap "33" } $"33"$
	}
	group "capture-stdout"
	mold\nowrap ?capture-stdout
	{ { block } }
	{
		equal { capture-stdout { "out" .print , "not this" } } "out" + newline
	}

	group "dump"
	mold\nowrap ?dump
	{ { any } { word } }
	{
		equal { fn { x } { x + 1 } |dump } { fn { x } { x ._+ 1 } } 
	}

	group "doc\of?"
	mold\nowrap ?doc\of?
	{ { function } }
	{
		equal { fn { x "docstring" } { x + 1 } |doc\of? } "docstring"
	}



}

$ section "Context functions"
"Functions that mostly work with blocks."
{
	group "doc"
	mold\nowrap ?doc
	{ { string  } }
	{
		; TODO
	}

	group "doc?"
	mold\nowrap ?doc?
	{ { } }
	{
		; TODO
	}

} $


section "Control functions"
"Program flow control functions"
{	
	
	group "if"
	mold\nowrap ?if
	{ { object } { block } }
	{
		equal { if 1 { 101 } } 101
		equal { if 0 { 101 } } 0
	}
	group "otherwise"
	mold\nowrap ?otherwise
	{ { object } { block } }
	{
		equal { otherwise 1 { 101 } } 0
		equal { otherwise 0 { 101 } } 101
	}
	group "^if"
	mold\nowrap ?^if
	{ { object } { block } }
	{
		equal { ^if 1 { 101 } } 101
		equal { ^if 0 { 101 } } 0
	}
	group "^otherwise"
	mold\nowrap ?^otherwise
	{ { object } { block } }
	{
		equal { ^otherwise 1 { 101 } } 0
		equal { ^otherwise 0 { 101 } } 101
	}
	group "either"
	mold\nowrap ?either
	{ { object } { block } { block } }
	{
		equal { either 1 { 101 } { 202 } } 101
		equal { either 0 { 101 } { 202 } } 202
	}
	group "switch"
	mold\nowrap ?switch
	{ { object } { block } }
	{
		equal { switch 1 { 1 { 101 } 2 { 202 } } } 101
		equal { switch 2 { 1 { 101 } 2 { 202 } } } 202
	}
	group "cases"
	mold\nowrap ?cases
	{ { object } { block } { block } }
	{
		equal { cases 1 { { 1 } { + 10 } { 1 } { + 100 } } } 111
		equal { cases 1 { { 0 } { + 10 } { 1 } { + 100 } } } 101
		; TODO cases doesn't do error handling well yet
	}
}

section "Doers and evaluators"
"Functions that do code and evaluate blocks."
{	
	
	group "do"
	mold\nowrap ?do
	{ { block } }
	{
		equal { do { 101 + 101 } } 202
	}

	group "do-in"
	mold\nowrap ?do-in
	{ { context } { block } }
	{
		equal { cc: context { x: 101 } do-in cc { x + 101 } } 202
	}

	group "do-with"
	mold\nowrap ?do-with
	{ { object } { block } }
	{
		equal { do-with 101 { + 101 } } 202
	}

	group "try"
	mold\nowrap ?try
	{ { block } }
	{
		equal { try { 10 + unknown } |type? } 'error 
	}
	
	group "do-in\try"
	mold\nowrap ?do-in\try
	{ { context } { block } }
	{
		equal { ctx: context { x: 101 } do-in\try ctx { x / 0 } |type? } 'error
	}

	group "vals"
	mold\nowrap ?vals
	{ { block } }
	{
		equal { x: 101 vals { x } } { 101 }
		equal { name: "Anne" vals { name "Goodall" } } { "Anne" "Goodall" }
		equal { y: 202 vals { 101  y  y + 101 } } { 101 202 303 }
		; TODO expression guards don't work
	}

	group "vals\with"
	mold\nowrap ?vals\with
	{ { object } { block } }
	{
		equal { vals\with 100 { + 1 } } { 101 }
		; TODO equal { x: 303 vals\with 100 { + 1 } } { 101 } ; loops forever
	}
}





section "Higher order like functions"
"Functions for usual HOF patterns, map, reduce, filter."
{	

	group "map"
	mold\nowrap ?map
	{ { block } { block } }
	{
		equal { map { 1 2 3 } { + 1 } } { 2 3 4 }
		equal { map { "a" "bb" "ccc" } { .length? } } { 1 2 3 }
	}	
	group "map\pos"
	mold\nowrap ?map
	{ { block } { block } }
	{
		equal { map { 1 2 3 } { + 1 } } { 2 3 4 }
		equal { map { "a" "bb" "ccc" } { .length? } } { 1 2 3 }
	}	
	group "filter"
	mold\nowrap ?map
	{ { block } { block } }
	{
		equal { map { 1 2 3 } { + 1 } } { 2 3 4 }
		equal { map { "a" "bb" "ccc" } { .length? } } { 1 2 3 }
	}	
	group "reduce"
	mold\nowrap ?map
	{ { block } { block } }
	{
		equal { map { 1 2 3 } { + 1 } } { 2 3 4 }
		equal { map { "a" "bb" "ccc" } { .length? } } { 1 2 3 }
	}	
	group "fold"
	mold\nowrap ?map
	{ { block } { block } }
	{
		equal { map { 1 2 3 } { + 1 } } { 2 3 4 }
		equal { map { "a" "bb" "ccc" } { .length? } } { 1 2 3 }
	}	
	group "produce"
	mold\nowrap ?map
	{ { block } { block } }
	{
		equal { map { 1 2 3 } { + 1 } } { 2 3 4 }
		equal { map { "a" "bb" "ccc" } { .length? } } { 1 2 3 }
	}	
	group "sum-up"
	mold\nowrap ?map
	{ { block } { block } }
	{
		equal { map { 1 2 3 } { + 1 } } { 2 3 4 }
		equal { map { "a" "bb" "ccc" } { .length? } } { 1 2 3 }
	}	
	group "seek"
	mold\nowrap ?map
	{ { block } { block } }
	{
		equal { map { 1 2 3 } { + 1 } } { 2 3 4 }
		equal { map { "a" "bb" "ccc" } { .length? } } { 1 2 3 }
	}	
	group "purge"
	mold\nowrap ?map
	{ { block } { block } }
	{
		equal { map { 1 2 3 } { + 1 } } { 2 3 4 }
		equal { map { "a" "bb" "ccc" } { .length? } } { 1 2 3 }
	}	
}

section "Context related functions"
"Functions for handling and working with Context."
{	
	
	group "current-ctx"
	mold\nowrap ?current-ctx
	{ }
	{
		equal { current-ctx |type? } 'ctx ; TODO should probably rename to context 
	}	

	group "parent-ctx"
	mold\nowrap ?parent-ctx
	{ }
	{
		equal { cc: context { f: does { parent-ctx |type? } } , cc/f } 'ctx
	}	

; TODO -- make something that clears color formatting or solve it some other way
;	group "ls"
;	mold\nowrap ?ls
;	{ }
;	{
;		example { cc: context { x: 123 , ls } } 'ctx
;	}	

	group "context"
	mold\nowrap ?context
	{ { block } }
	{
		equal { cc: context { } |type? } 'ctx
	}	

	group "isolate"
	mold\nowrap ?isolate
	{ { block } }
	{
		equal { cc: isolate { } |type? } 'ctx
	}	

	group "raw-context"
	mold\nowrap ?raw-context
	{ { block } }
	{
		equal { cc: raw-context { } |type? } 'ctx
	}	

	group "private"
	mold\nowrap ?raw-context
	{ { block } }
	{
		equal { cc: raw-context { } |type? } 'ctx
	}	

	group "extend"
	mold\nowrap ?raw-context
	{ { block } }
	{
		equal { cc: raw-context { } |type? } 'ctx
	}	

	group "bind"
	mold\nowrap ?raw-context
	{ { block } }
	{
		equal { cc: raw-context { } |type? } 'ctx
	}	

	group "unbind"
	mold\nowrap ?raw-context
	{ { block } }
	{
		equal { cc: raw-context { } |type? } 'ctx
	}	

}

section "Functions that change values in-place"
"Functions that mostly work with blocks."
{

	group "inc!"
	mold\nowrap ?inc!
	{ { word } }
	{
		equal { a: 100 , inc! 'a } 101 
		equal { a: 100 , inc! 'a , a } 101 
	}

	group "change!"
	mold\nowrap ?change!
	{ { any } { word } }
	{
		equal { a: 1 change! 2 'a } 1
		equal { a: 2 change! 2 'a } 0
	}

	comment "Functions that change values in-place are used more rarely in Rye and have ! at the end."
	
	group "remove-last!"
	mold\nowrap ?remove-last!
	{ { word } }
	{
		equal { b: { 1 2 3 } , remove-last! 'b , b } { 1 2 }
	}
	
	group "append!"
	mold\nowrap ?append!
	{ { word } { object } }
	{
		equal { b: { 1 2 3 } , append! 4 'b , b } { 1 2 3 4 }
		equal { b: { 1 2 3 } , append! { 4 5 } 'b , b } { 1 2 3 { 4 5 } }
	}
	
}


;	TODO	equal { list { 3 4 5 6 } |map { .factor-of 3 } } list { 1 0 0 1 } 


stats